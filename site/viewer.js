/* ---------- DOM ---------- */
const daysEl    = document.getElementById('days');
const listEl    = document.getElementById('list');
const metaEl    = document.getElementById('meta');
const qEl       = document.getElementById('q');
const toolbarEl = document.getElementById('toolbar');
const introEl   = document.getElementById('intro');
const dropEl    = document.getElementById('drop');

const btnCloud  = document.getElementById('mode-cloud');
const btnLocal  = document.getElementById('mode-local');
const btnPaste  = document.getElementById('mode-paste');
const fileEl    = document.getElementById('file');

const btnExport = document.getElementById('export-md');
const btnClear  = document.getElementById('clear-cache');

/* ---------- Paste Modal ---------- */
const modal     = document.getElementById('paste-modal');
const area      = document.getElementById('paste-area');
const btnPCancel= document.getElementById('paste-cancel');
const btnPRun   = document.getElementById('paste-run');

/* ---------- Local cache helpers ---------- */
const LS_INDEX_KEY   = 'cgpt.questions.index.v1';
const LS_DAY_PREFIX  = 'cgpt.questions.day.v1:'; // one entry per day

function saveIndexToLocal(index) {
  try { localStorage.setItem(LS_INDEX_KEY, JSON.stringify(index)); } catch {}
}
function loadIndexFromLocal() {
  const raw = localStorage.getItem(LS_INDEX_KEY);
  if (!raw) return null;
  try { return JSON.parse(raw); } catch { return null; }
}
function saveDayToLocal(dayObj) {
  try { localStorage.setItem(LS_DAY_PREFIX + dayObj.day, JSON.stringify(dayObj)); } catch {}
}
function loadDayFromLocal(day) {
  const raw = localStorage.getItem(LS_DAY_PREFIX + day);
  if (!raw) return null;
  try { return JSON.parse(raw); } catch { return null; }
}
function clearLocalCache() {
  try {
    localStorage.removeItem(LS_INDEX_KEY);
    const keys = Object.keys(localStorage);
    for (const k of keys) {
      if (k.startsWith(LS_DAY_PREFIX)) localStorage.removeItem(k);
    }
  } catch {}
}

/* ---------- State ---------- */
let MODE = 'cloud';        // 'cloud' | 'local'
let INDEX = null;          // { days: [{day,count,keywords:[...] }], totalCount }
let CURRENT = null;        // { day, items:[{time, text, conv, id}], count, keywords }
let LOCAL_QUESTIONS = null;// Map by day when parsing local JSON without caching (fallback)

/* ---------- Mode controls ---------- */
function setMode(m) {
  MODE = m;
  btnCloud.classList.toggle('active', m === 'cloud');
  btnLocal.classList.toggle('active', m === 'local');
}

/* ---------- Event wiring ---------- */
btnCloud.onclick = () => loadIndex();
btnLocal.onclick = () => {
  const cached = loadIndexFromLocal();
  if (!cached) {
    alert('No local cache yet. Use “Paste JSON” or “Upload JSON” first.');
    return;
  }
  INDEX = cached;
  setMode('local');
  renderDays();
  introEl.classList.add('hidden');
};

btnPaste.onclick   = () => { modal.classList.remove('hidden'); area.value = ''; area.focus(); };
btnPCancel.onclick = () => modal.classList.add('hidden');
btnPRun.onclick    = async () => {
  const text = area.value.trim();
  if (!text) return alert('Nothing pasted.');
  let json;
  try { json = JSON.parse(text); }
  catch { return alert('Invalid JSON. Paste the raw conversations.json.'); }

  await processLocalJSON(json, /*cache*/true);
  modal.classList.add('hidden');
};

fileEl.onchange = async (e) => {
  const f = e.target.files[0];
  if (!f) return;
  const txt = await f.text();
  let json;
  try { json = JSON.parse(txt); }
  catch { return alert('Invalid JSON file.'); }
  await processLocalJSON(json, /*cache*/true);
};

qEl.addEventListener('input', () => renderList());

btnExport.onclick = () => {
  if (!CURRENT) return;
  const md = toMarkdown(CURRENT);
  const blob = new Blob([md], { type: 'text/markdown;charset=utf-8' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `questions-${CURRENT.day}.md`;
  a.click();
  URL.revokeObjectURL(url);
};

btnClear.onclick = () => {
  if (!confirm('Clear local cache? This only affects your browser.')) return;
  clearLocalCache();
  alert('Local cache cleared.');
};

/* Optional drag/drop large file */
;(() => {
  if (!dropEl) return;
  function on(e) { e.preventDefault(); e.stopPropagation(); }
  ['dragenter','dragover','dragleave','drop'].forEach(ev => dropEl.addEventListener(ev, on));
  dropEl.addEventListener('drop', async (e) => {
    const f = e.dataTransfer.files && e.dataTransfer.files[0];
    if (!f) return;
    const txt = await f.text();
    let json; try { json = JSON.parse(txt); } catch { return alert('Invalid JSON'); }
    await processLocalJSON(json, /*cache*/true);
  });
})();

/* ---------- Core loaders ---------- */
async function loadIndex() {
  // Cloud index is ./data/index.json (generated by GitHub Action)
  setMode('cloud');
  try {
    const res = await fetch('./data/index.json', { cache: 'no-store' });
    if (!res.ok) throw new Error('no cloud data');
    INDEX = await res.json();
    renderDays();
    introEl.classList.add('hidden');
  } catch (err) {
    INDEX = { days: [], totalCount: 0 };
    renderDays();
    introEl.classList.remove('hidden');
    introEl.querySelector('.status') && (introEl.querySelector('.status').textContent = 'No cloud data yet.');
  }
}

async function openDay(day) {
  toolbarEl.classList.remove('hidden');
  if (MODE === 'cloud') {
    const res = await fetch(`./data/day-${day}.json`, { cache: 'no-store' });
    CURRENT = await res.json();
  } else {
    // prefer cache
    CURRENT = loadDayFromLocal(day);
    if (!CURRENT && LOCAL_QUESTIONS) {
      CURRENT = LOCAL_QUESTIONS[day];
    }
  }
  metaEl.textContent = `${CURRENT.count || CURRENT.items.length} questions`;
  qEl.value = '';
  renderList();
}

/* ---------- Local JSON processing ---------- */
async function processLocalJSON(json, cache = true) {
  // Parse raw ChatGPT export -> per-day compact structure
  const byDate = extractQuestions(json); // { 'YYYY-MM-DD': {day, items, count, keywords} }
  LOCAL_QUESTIONS = byDate;
  const index = buildIndex(byDate);      // { days:[{day,count,keywords}], totalCount }

  if (cache) {
    clearLocalCache();
    saveIndexToLocal(index);
    for (const d of index.days) {
      const dayObj = byDate[d.day];
      saveDayToLocal(dayObj);
    }
  }

  INDEX = index;
  setMode('local');
  renderDays();
  introEl.classList.add('hidden');
}

/* ---------- Rendering ---------- */
function renderDays() {
  daysEl.innerHTML = '';
  const days = (INDEX && INDEX.days) ? INDEX.days : [];
  if (!days.length) {
    const p = document.createElement('p');
    p.className = 'muted';
    p.textContent = (MODE === 'cloud')
      ? 'No cloud data yet. Publish a Release with conversations.json.'
      : 'No local data. Use “Paste JSON” or “Upload JSON”.';
    daysEl.appendChild(p);
    listEl.innerHTML = '';
    metaEl.textContent = '';
    return;
  }

  for (const d of days) {
    const btn = document.createElement('button');
    btn.className = 'day';
    btn.innerHTML = `
      <div class="when">${d.day}</div>
      <div class="count">${d.count} q</div>
      <div class="keys">${(d.keywords||[]).slice(0,5).map(k=>`<span>${esc(k)}</span>`).join('')}</div>
    `;
    btn.onclick = () => openDay(d.day);
    daysEl.appendChild(btn);
  }
}

function renderList() {
  const q = (qEl.value || '').trim().toLowerCase();
  const items = (!CURRENT ? [] : CURRENT.items);
  let shown = 0;
  listEl.innerHTML = '';

  for (const it of items) {
    if (q && !it.text.toLowerCase().includes(q)) continue;
    shown++;
    const row = document.createElement('div');
    row.className = 'row';
    row.innerHTML = `
      <div class="time">${it.time}</div>
      <div class="txt">${linkify(esc(it.text))}</div>
      ${it.conv ? `<div class="meta">• ${esc(it.conv)}</div>` : ''}
    `;
    listEl.appendChild(row);
  }

  metaEl.textContent = `${shown} / ${(CURRENT && CURRENT.items.length) || 0} questions`;
}

/* ---------- Markdown export ---------- */
function toMarkdown(dayObj) {
  const lines = [];
  lines.push(`# Questions — ${dayObj.day}`);
  lines.push('');
  for (const it of dayObj.items) {
    lines.push(`- **${it.time}** — ${it.text.replace(/\s+/g, ' ').trim()}`);
  }
  lines.push('');
  return lines.join('\n');
}

/* ---------- Parsers (robust across export shapes) ---------- */
/**
 * Accepts various ChatGPT exports and returns:
 * { 'YYYY-MM-DD': { day, items:[{time,text,conv,id}], count, keywords } }
 */
function extractQuestions(json) {
  const byDay = {};
  const push = (tsMs, text, conv, id) => {
    if (!text) return;
    const date = new Date(tsMs);
    const day = isoDay(date);
    const time = date.toTimeString().slice(0,5);
    if (!byDay[day]) byDay[day] = { day, items: [] };
    byDay[day].items.push({ time, text: squashWhitespace(text), conv, id });
  };

  // Multiple possible shapes
  // 1) { conversations: [ { id, title, create_time, mapping:{ id:{message:{author:{role}, content:{parts:[]|text}, create_time}} } } ] }
  if (Array.isArray(json.conversations)) {
    for (const c of json.conversations) {
      const convTitle = c.title || '';
      if (c.mapping && typeof c.mapping === 'object') {
        for (const key of Object.keys(c.mapping)) {
          const node = c.mapping[key];
          const msg  = node && node.message;
          if (!msg) continue;
          const role = (msg.author && msg.author.role) || '';
          if (role !== 'user') continue;
          const ts = (msg.create_time ? toMs(msg.create_time) : Date.now());
          const text = contentToText(msg.content);
          push(ts, text, convTitle, msg.id || key);
        }
      } else if (Array.isArray(c.messages)) {
        for (const m of c.messages) {
          const role = (m.author && m.author.role) || m.role || '';
          if (role !== 'user') continue;
          const ts = toMs(m.create_time || m.create_time_ts || m.timestamp || Date.now());
          const text = contentToText(m.content || m.text || m.parts);
          push(ts, text, convTitle, m.id);
        }
      }
    }
  }
  // 2) { items: [ { id, title, mapping: {...} } ] }  (older)
  else if (Array.isArray(json.items)) {
    for (const c of json.items) {
      const convTitle = c.title || '';
      if (c.mapping && typeof c.mapping === 'object') {
        for (const key of Object.keys(c.mapping)) {
          const node = c.mapping[key];
          const msg  = node && node.message;
          if (!msg) continue;
          const role = (msg.author && msg.author.role) || '';
          if (role !== 'user') continue;
          const ts = (msg.create_time ? toMs(msg.create_time) : Date.now());
          const text = contentToText(msg.content);
          push(ts, text, convTitle, msg.id || key);
        }
      } else if (Array.isArray(c.messages)) {
        for (const m of c.messages) {
          const role = (m.author && m.author.role) || m.role || '';
          if (role !== 'user') continue;
          const ts = toMs(m.create_time || m.create_time_ts || m.timestamp || Date.now());
          const text = contentToText(m.content || m.text || m.parts);
          push(ts, text, convTitle, m.id);
        }
      }
    }
  }
  // 3) { messages: [...] } (rare)
  else if (Array.isArray(json.messages)) {
    for (const m of json.messages) {
      const role = (m.author && m.author.role) || m.role || '';
      if (role !== 'user') continue;
      const ts = toMs(m.create_time || m.timestamp || Date.now());
      const text = contentToText(m.content || m.text || m.parts);
      push(ts, text, json.title || '', m.id);
    }
  }
  // 4) fallback: maybe already compact by-day structure
  else if (json && typeof json === 'object' && json.days && Array.isArray(json.days)) {
    // Treat as index + external day files (do nothing)
  }

  // Sort each day chronologically and finish fields
  for (const day of Object.keys(byDay)) {
    byDay[day].items.sort((a,b) => a.time.localeCompare(b.time));
    byDay[day].count = byDay[day].items.length;
    byDay[day].keywords = topKeywords(byDay[day].items.map(x => x.text).join('\n'));
  }
  return byDay;
}

/** Build sidebar index */
function buildIndex(byDay) {
  const days = Object.values(byDay).map(d => ({
    day: d.day,
    count: d.count || (d.items ? d.items.length : 0),
    keywords: d.keywords || []
  }));
  days.sort((a,b) => b.day.localeCompare(a.day));
  const total = days.reduce((s,d)=>s+d.count,0);
  return { days, totalCount: total };
}

/* ---------- Utilities ---------- */
function esc(s){ return String(s || '').replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }
function linkify(s){
  return s.replace(/\bhttps?:\/\/[^\s)]+/g, u => `<a href="${u}" target="_blank" rel="noopener">${u}</a>`);
}
function isoDay(d){ return d.toISOString().slice(0,10); }
function toMs(t){
  if (!t) return Date.now();
  if (typeof t === 'number') {
    // seconds vs ms
    return (t < 1e12 ? t * 1000 : t);
  }
  // ISO string
  const ms = Date.parse(t);
  return isNaN(ms) ? Date.now() : ms;
}
function contentToText(content){
  if (!content) return '';
  if (typeof content === 'string') return content;
  if (Array.isArray(content)) return content.filter(Boolean).join('\n');
  if (content.parts && Array.isArray(content.parts)) return content.parts.filter(Boolean).join('\n');
  if (content.text) return content.text;
  try { return JSON.stringify(content); } catch { return String(content); }
}
function squashWhitespace(s){ return (s||'').replace(/\s+/g,' ').trim(); }

/** crude keyword extraction (stopwords + frequency) */
const STOP = new Set(('the of a an and or to in on at for with is are was were be been being do does did doing from by as that this it its i you your me my we our they them their he she his her not no if then else when where how what which who whom why').split(/\s+/));
function topKeywords(text){
  const freq = Object.create(null);
  for (const raw of text.toLowerCase().split(/[^a-z0-9+#/@.]+/g)) {
    const w = raw.replace(/^#+/,''); // allow #tags but strip rank bias
    if (!w || STOP.has(w) || w.length < 3) continue;
    freq[w] = (freq[w]||0)+1;
  }
  return Object.entries(freq).sort((a,b)=>b[1]-a[1]).slice(0,8).map(([w])=>w);
}

/* ---------- Boot: try local cache first ---------- */
(function boot(){
  const cached = loadIndexFromLocal();
  if (cached) {
    INDEX = cached;
    setMode('local');
    renderDays();
    introEl.classList.add('hidden');
  } else {
    setMode('cloud');
    loadIndex(); // may show "No cloud data yet"
  }
})();
